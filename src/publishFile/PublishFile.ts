import { MetadataCache, TFile, Vault } from "obsidian";
import {
	GardenPageCompiler,
	TCompiledFile,
} from "../compiler/GardenPageCompiler";
import {
	FrontmatterCompiler,
	TFrontmatter,
} from "../compiler/FrontmatterCompiler";
import DigitalGardenSettings from "../models/settings";
import { hasPublishFlag } from "./Validator";
import { FileMetadataManager } from "./FileMetaDataManager";

interface IPublishFileProps {
	file: TFile;
	vault: Vault;
	compiler: GardenPageCompiler;
	metadataCache: MetadataCache;
	settings: DigitalGardenSettings;
}

export class PublishFile {
	file: TFile;
	compiler: GardenPageCompiler;
	vault: Vault;
	compiledFile?: TCompiledFile;
	metadataCache: MetadataCache;
	frontmatter: TFrontmatter;
	settings: DigitalGardenSettings;
	// Access dg-props and other file metadata
	meta: FileMetadataManager;

	constructor({
		file,
		compiler,
		metadataCache,
		vault,
		settings,
	}: IPublishFileProps) {
		this.compiler = compiler;
		this.metadataCache = metadataCache;
		this.file = file;
		this.settings = settings;
		this.vault = vault;
		this.frontmatter = this.getFrontmatter();

		this.meta = new FileMetadataManager(file, this.frontmatter, settings);
	}

	async compile(): Promise<CompiledPublishFile> {
		const compiledFile = await this.compiler.generateMarkdown(this);

		return new CompiledPublishFile(
			{
				file: this.file,
				compiler: this.compiler,
				metadataCache: this.metadataCache,
				vault: this.vault,
				settings: this.settings,
			},
			compiledFile,
		);
	}

	getType(): "excalidraw" | "canvas" | "markdown" {
		if (this.file.name.endsWith(".excalidraw.md")) {
			return "excalidraw";
		}

		if (this.file.extension === "canvas") {
			return "canvas";
		}

		return "markdown";
	}

	shouldPublish(): boolean {
		return hasPublishFlag(this.frontmatter);
	}

	async getImageLinks() {
		return this.compiler.extractImageLinks(this);
	}

	async cachedRead() {
		return this.vault.cachedRead(this.file);
	}

	getMetadata() {
		return this.metadataCache.getCache(this.file.path) ?? {};
	}

	getBlock(blockId: string) {
		return this.getMetadata().blocks?.[blockId];
	}

	getFrontmatter() {
		return this.metadataCache.getCache(this.file.path)?.frontmatter ?? {};
	}

	/**
	 * For canvas files, frontmatter is stored in the JSON metadata field.
	 * This method reads it directly from the file content.
	 */
	async getCanvasFrontmatter(): Promise<Record<string, unknown>> {
		if (this.file.extension !== "canvas") {
			return this.getFrontmatter();
		}

		try {
			const content = await this.vault.cachedRead(this.file);
			const canvasData = JSON.parse(content);

			return canvasData?.metadata?.frontmatter ?? {};
		} catch {
			return {};
		}
	}

	/** Add other possible sorting logic here, eg if we add dg-sortWeight
	 * We might also want to sort by meta.getPath for rewritten garden path
	 */
	compare(other: PublishFile) {
		return this.file.path.localeCompare(other.file.path);
	}

	getPath = () => this.file.path;
	getCompiledFrontmatter() {
		const frontmatterCompiler = new FrontmatterCompiler(this.settings);

		const metadata =
			this.metadataCache.getCache(this.file.path)?.frontmatter ?? {};

		return frontmatterCompiler.compile(this, metadata);
	}
}

export class CompiledPublishFile extends PublishFile {
	compiledFile: TCompiledFile;
	remoteHash?: string;

	constructor(props: IPublishFileProps, compiledFile: TCompiledFile) {
		super(props);

		this.compiledFile = compiledFile;
	}

	getCompiledFile() {
		return this.compiledFile;
	}

	setRemoteHash(hash: string) {
		this.remoteHash = hash;
	}

	/**
	 * Returns content suitable for hash comparison.
	 * Auto-generated timestamps (from file.stat) are stripped to avoid false-positive
	 * "changed" detection when file sync updates mtime without actual content changes.
	 * User-managed timestamps (via custom frontmatter keys) are preserved.
	 */
	getContentForHashComparison(): string {
		const [content] = this.getCompiledFile();

		const hasUserCreatedKey = !!this.settings.createdTimestampKey;
		const hasUserUpdatedKey = !!this.settings.updatedTimestampKey;

		// If both timestamps are user-managed, return full content
		if (hasUserCreatedKey && hasUserUpdatedKey) {
			return content;
		}

		return this.stripAutoGeneratedTimestamps(
			content,
			hasUserCreatedKey,
			hasUserUpdatedKey,
		);
	}

	/**
	 * Strips auto-generated timestamps from frontmatter for stable hash comparison.
	 * Only removes "created" and/or "updated" fields when they are NOT user-managed.
	 */
	private stripAutoGeneratedTimestamps(
		content: string,
		keepCreated: boolean,
		keepUpdated: boolean,
	): string {
		// Match frontmatter pattern: ---\n{JSON}\n---\n
		const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/);

		if (!frontmatterMatch) {
			return content;
		}

		const frontmatterJson = frontmatterMatch[1];
		const restOfContent = content.slice(frontmatterMatch[0].length);

		try {
			const frontmatter = JSON.parse(frontmatterJson);

			// Remove auto-generated timestamps
			if (!keepCreated && "created" in frontmatter) {
				delete frontmatter.created;
			}

			if (!keepUpdated && "updated" in frontmatter) {
				delete frontmatter.updated;
			}

			const newFrontmatterJson = JSON.stringify(frontmatter);

			return `---\n${newFrontmatterJson}\n---\n${restOfContent}`;
		} catch {
			// If frontmatter isn't valid JSON, return original content
			return content;
		}
	}
}
